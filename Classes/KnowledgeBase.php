<?php
declare(ENCODING = 'utf-8') ;
namespace Erfurt;
/***************************************************************
 *  Copyright notice
 *
 *  (c) 2011 Thomas Maroschik <tmaroschik@dfau.de>
 *  All rights reserved
 *
 *  This class is a port of the corresponding class of the
 *  {@link http://aksw.org/Projects/Erfurt Erfurt} project.
 *  All credits go to the Erfurt team.
 *
 *  This script is part of the TYPO3 project. The TYPO3 project is
 *  free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  The GNU General Public License can be found at
 *  http://www.gnu.org/copyleft/gpl.html.
 *
 *  This script is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  This copyright notice MUST APPEAR in all copies of the script!
 ***************************************************************/
/******************************************************************************
* CONSTANTS                                                                   *
******************************************************************************/
// TODO use a vocabulary adapter in order to have a cleaner file and not so much constants

// some namespace definitions
define('EF_XML_NS', 'http://www.w3.org/XML/1998/namespace');
define('EF_XSD_NS', 'http://www.w3.org/2001/XMLSchema#');
define('EF_RDF_NS', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#');
define('EF_RDFS_NS', 'http://www.w3.org/2000/01/rdf-schema#');
define('EF_OWL_NS', 'http://www.w3.org/2002/07/owl#');

define('EF_OWL_IMPORTS', EF_OWL_NS.'imports');
define('EF_OWL_ONTOLOGY', EF_OWL_NS.'Ontology');
define('EF_OWL_SAMEAS', EF_OWL_NS.'sameAs');
define('EF_OWL_DIFFERENTFROM', EF_OWL_NS.'differentFrom');
define('EF_OWL_CARDINALITY', EF_OWL_NS.'cardinality');
define('EF_OWL_MINCARDINALITY', EF_OWL_NS.'minCardinality');
define('EF_OWL_MAXCARDINALITY', EF_OWL_NS.'maxCardinality');
define('EF_OWL_HASVALUE', EF_OWL_NS.'hasValue');
define('EF_OWL_SOMEVALUESFROM', EF_OWL_NS.'someValuesFrom');
define('EF_OWL_ALLVALUESFROM', EF_OWL_NS.'allValuesFrom');
define('EF_OWL_INTERSECTIONOF', EF_OWL_NS.'intersectionOf');
define('EF_OWL_EQUIVALENTCLASS', EF_OWL_NS.'equivalentClass');
define('EF_OWL_DISJOINTWITH', EF_OWL_NS.'disjointWith');
define('EF_OWL_CLASS', EF_OWL_NS.'Class');
define('EF_OWL_DEPRECATED_CLASS', EF_OWL_NS.'DeprecatedClass');
define('EF_OWL_ANNOTATION_PROPERTY', EF_OWL_NS.'AnnotationProperty');
define('EF_OWL_ONTOLOGY_PROPERTY', EF_OWL_NS.'OntologyProperty');
define('EF_OWL_DATATYPE_PROPERTY', EF_OWL_NS.'DatatypeProperty');
define('EF_OWL_OBJECT_PROPERTY', EF_OWL_NS.'ObjectProperty');
define('EF_OWL_FUNCTIONAL_PROPERTY', EF_OWL_NS.'FunctionalProperty');
define('EF_OWL_INVERSEFUNCTIONAL_PROPERTY', EF_OWL_NS.'InverseFunctionalProperty');
define('EF_OWL_SYMMETRIC_PROPERTY', EF_OWL_NS.'SymmetricProperty');
define('EF_OWL_TRANSITIVE_PROPERTY', EF_OWL_NS.'TransitiveProperty');
define('EF_OWL_DEPRECATED_PROPERTY', EF_OWL_NS.'DeprecatedProperty');
define('EF_OWL_RESTRICTION', EF_OWL_NS.'Restriction');
define('EF_OWL_ONEOF', EF_OWL_NS.'oneOf');
define('EF_OWL_THING', EF_OWL_NS.'Thing');
define('EF_OWL_ONPROPERTY', EF_OWL_NS.'onProperty');
define('EF_OWL_ALLDIFFERENT', EF_OWL_NS.'AllDifferent');
define('EF_OWL_UNIONOF', EF_OWL_NS.'unionOf');
define('EF_OWL_COMPLEMENTOF', EF_OWL_NS.'complementOf');

define('EF_RDF_TYPE', EF_RDF_NS.'type');
define('EF_RDF_DESCRIPTION', EF_RDF_NS.'Description');
define('EF_RDF_ABOUT', EF_RDF_NS.'about');
define('EF_RDF_NIL', EF_RDF_NS.'nil');
define('EF_RDF_FIRST', EF_RDF_NS.'first');
define('EF_RDF_REST', EF_RDF_NS.'rest');
define('EF_RDF_PROPERTY', EF_RDF_NS.'Property');

define('EF_RDFS_COMMENT', EF_RDFS_NS.'comment');
define('EF_RDFS_LABEL', EF_RDFS_NS.'label');
define('EF_RDFS_SUBCLASSOF', EF_RDFS_NS.'subClassOf');
define('EF_RDFS_SUBPROPERTYOF', EF_RDFS_NS.'subPropertyOf');
define('EF_RDFS_DATATYPE', EF_RDFS_NS.'Datatype');
define('EF_RDFS_CLASS', EF_RDFS_NS.'Class');
define('EF_RDFS_DOMAIN', EF_RDFS_NS.'domain');
define('EF_RDFS_RANGE', EF_RDFS_NS.'range');
define('EF_RDFS_RESOURCE', EF_RDFS_NS.'Resource');

define('EF_XSD_STRING', EF_XSD_NS.'string');
define('EF_XSD_INTEGER', EF_XSD_NS.'integer');
define('EF_XSD_DECIMAL', EF_XSD_NS.'decimal');
define('EF_XSD_DOUBLE', EF_XSD_NS.'double');
define('EF_XSD_BOOLEAN', EF_XSD_NS.'boolean');
define('EF_XSD_DATETIME', EF_XSD_NS.'dateTime');

define('EF_BNODE_PREFIX', 'node');

define('EF_SERIALIZER_AD', 'Generated by Erfurt Semantic Web Framework - http://sourceforge.net/projects/powl');
/**
 * This is an alternative entry point to the erfurt library
 *
 * @package Semantic
 * @scope singleton
 * @api
 */
class KnowledgeBase implements \Erfurt\Singleton {
	/**
	 * Constant that contains the minimum required php version.
	 * @var string
	 */
	const EF_MIN_PHP_VERSION = '5.2.0';

	/**
	 * Constant that contains the minimum required zend framework version.
	 * @var string
	 */
	const EF_MIN_ZEND_VERSION = '1.5.0';

	// ------------------------------------------------------------------------
	// --- protected properties -------------------------------------------------
	// ------------------------------------------------------------------------

	/**
	 * Contains an instance of the Erfurt access control class.
	 * @var \Erfurt\AccessControl\Standard
	 */
	protected $accessControl;

	/**
	 * Contains an instanciated access control model.
	 * @var \Erfurt\Rdf\Model
	 */
	protected $accessControlModel;

	/**
	 * @var \Erfurt\Authentication\Authentication
	 */
	protected $authentication;

	/**
	 * Contains the cache object.
	 * @var \Zend_Cache_Core
	 */
	protected $cache;

	/**
	 * Contains the cache backend.
	 * @var \Zend_Cache_Backend
	 */
	protected $cacheBackend;

	/**
	 * Contains an instance of the configuration object.
	 * @var \Zend_Config
	 */
	protected $configuration;

	/**
	 * @var \Erfurt\Configuration\AccessControlConfiguration
	 */
	protected $accessControlConfiguration;

	/**
	 * @var \Erfurt\Configuration\AuthenticationConfiguration
	 */
	protected $authenticationConfiguration;

	/**
	 * @var \Erfurt\Configuration\CacheConfiguration
	 */
	protected $cacheConfiguration;

	/**
	 * @var \Erfurt\Configuration\GeneralConfiguration
	 */
	protected $generalConfiguration;

	/**
	 * @var \Erfurt\Configuration\NamespacesConfiguration
	 */
	protected $namespacesConfiguration;

	/**
	 * @var \Erfurt\Configuration\SessionConfiguration
	 */
	protected $sessionConfiguration;

	/**
	 * @var \Erfurt\Configuration\StoreConfiguration
	 */
	protected $storeConfiguration;

	/**
	 * @var \Erfurt\Configuration\SystemOntologyConfiguration
	 */
	protected $systemOntologyConfiguration;

	/**
	 * @var \Erfurt\Configuration\UriConfiguration
	 */
	protected $uriConfiguration;

	/**
	 * The injected knowledge base
	 *
	 * @var \Erfurt\Object\ObjectManager
	 */
	protected $objectManager;

	/**
	 * Namespace management module
	 * @var Erfurt_Namespaces
	 */
	protected $namespaces;

	/**
	 * Contains the query cache object.
	 * @var \Erfurt\Cache\Frontend\QueryCache
	 */
	protected $queryCache;

	/**
	 * Contains the query cache backend.
	 * @var \Erfurt\Cache\Backend\QueryCache\Backend
	 */
	protected $queryCacheBackend;

	/**
	 * Contains an instance of the store.
	 * @var \Erfurt\Store\Store
	 */
	protected $store;

	/**
	 * Contains an instanciated system ontology model.
	 * @var \Erfurt\Rdf\Model
	 */
	protected $systemOntologyModel;

	/**
	 * Contains an instance of the Erfurt versioning class.
	 *
	 * @var Erfurt_Versioning
	 */
	protected $versioning;

	/**
	 * Override Erfurt App constructor
	 */
	public function __construct() {
	}

	/**
	 * Injector method for a \Erfurt\Authentication\Authentication
	 *
	 * @var \Erfurt\Authentication\Authentication
	 */
	public function injectAuthentication(\Erfurt\Authentication\Authentication $authentication) {
		$this->authentication = $authentication;
	}

	/**
	 * Injector method for a AccessControlConfiguration
	 *
	 * @var \Erfurt\Configuration\AccessControlConfiguration
	 */
	public function injectAccessControlConfiguration(Configuration\AccessControlConfiguration $accessControlConfiguration) {
		$this->accessControlConfiguration = $accessControlConfiguration;
	}

	/**
	 * Injector method for a AuthenticationConfiguration
	 *
	 * @var \Erfurt\Configuration\AuthenticationConfiguration
	 */
	public function injectAuthenticationConfiguration(Configuration\AuthenticationConfiguration $authenticationConfiguration) {
		$this->authenticationConfiguration = $authenticationConfiguration;
	}

	/**
	 * Injector method for a CacheConfiguration
	 *
	 * @var \Erfurt\Configuration\CacheConfiguration
	 */
	public function injectCacheConfiguration(Configuration\CacheConfiguration $cacheConfiguration) {
		$this->cacheConfiguration = $cacheConfiguration;
	}

	/**
	 * Injector method for a GeneralConfiguration
	 *
	 * @var \Erfurt\Configuration\GeneralConfiguration
	 */
	public function injectGeneralConfiguration(Configuration\GeneralConfiguration $generalConfiguration) {
		$this->generalConfiguration = $generalConfiguration;
	}

	/**
	 * Injector method for a NamespacesConfiguration
	 *
	 * @var \Erfurt\Configuration\NamespacesConfiguration
	 */
	public function injectNamespacesConfiguration(Configuration\NamespacesConfiguration $namespacesConfiguration) {
		$this->namespacesConfiguration = $namespacesConfiguration;
	}

	/**
	 * Injector method for a SessionConfiguration
	 *
	 * @var \Erfurt\Configuration\SessionConfiguration
	 */
	public function injectSessionConfiguration(Configuration\SessionConfiguration $sessionConfiguration) {
		$this->sessionConfiguration = $sessionConfiguration;
	}

	/**
	 * Injector method for a StoreConfiguration
	 *
	 * @var \Erfurt\Configuration\StoreConfiguration
	 */
	public function injectStoreConfiguration(Configuration\StoreConfiguration $storeConfiguration) {
		$this->storeConfiguration = $storeConfiguration;
	}

	/**
	 * Injector method for a SystemOntologyConfiguration
	 *
	 * @var \Erfurt\Configuration\SystemOntologyConfiguration
	 */
	public function injectSystemOntologyConfiguration(Configuration\SystemOntologyConfiguration $systemOntologyConfiguration) {
		$this->systemOntologyConfiguration = $systemOntologyConfiguration;
	}

	/**
	 * Injector method for a UriConfiguration
	 *
	 * @var \Erfurt\Configuration\UriConfiguration
	 */
	public function injectUriConfiguration(Configuration\UriConfiguration $uriConfiguration) {
		$this->uriConfiguration = $uriConfiguration;
	}

	/**
	 * Injector method for a \Erfurt\Object|ObjectManager
	 *
	 * @var \Erfurt\Object|ObjectManager
	 */
	public function injectObjectManager(\Erfurt\Object\ObjectManager $objectManager) {
		$this->objectManager = $objectManager;
	}

	/**
	 * Injector method for a \Erfurt\Store\Store
	 *
	 * @var \Erfurt\Store\Store
	 */
	public function injectStore(\Erfurt\Store\Store $store) {
		$this->store = $store;
	}

	/**
	 * Starts the application, which initializes it.
	 *
	 * @param Zendconfiguration|NULL $config An optional config object that will be merged with
	 * the Erfurt config.
	 *
	 * @return \Erfurt\KnowledgeBase
	 * @throws \Erfurt\Exception( Throws an exception if the connection to the backend server fails.
	 */
	protected function initializeObject() {
		// Check for debug mode.
		$configuration = $this->getConfiguration();
		// Set the configured time zone.
		if (isset($configuration->timezone) && ((boolean)$configuration->timezone !== false)) {
			date_default_timezone_set($configuration->timezone);
		} else {
			date_default_timezone_set('Europe/Berlin');
		}
		// Starting Versioning
		try {
			$versioning = $this->getVersioning();
			if ((boolean)$configuration->versioning === false) {
				$versioning->enableVersioning(false);
			}
		}
		catch (\Erfurt\Exception $e) {
			throw new \Erfurt\Exception($e->getMessage());
		}
		return $this;
	}

	/**
	 * Adds a new OpenID user to the store.
	 *
	 * @param string $openid
	 * @param string $email
	 * @param string $label
	 * @param string|NULL $group
	 * @return boolean
	 */
	public function addOpenIdUser($openid, $email = '', $label = '', $group = '') {
		$acModel = $this->getAccessControlModel();
		$acModelUri = $acModel->getModelUri();
		$store = $acModel->getStore();
		$userUri = urldecode($openid);
		// uri rdf:type sioc:User
		$store->addStatement(
			$acModelUri,
			$userUri,
			EF_RDF_TYPE,
			array(
				 'value' => $this->configuration->ac->user->class,
				 'type' => 'uri'
			),
			false
		);
		if (!empty($email)) {
			// Check whether email already starts with mailto:
			if (substr($email, 0, 7) !== 'mailto:') {
				$email = 'mailto:' . $email;
			}
			// uri sioc:mailbox email
			$store->addStatement(
				$acModelUri,
				$userUri,
				$this->configuration->ac->user->mail,
				array(
					 'value' => $email,
					 'type' => 'uri'
				),
				false
			);
		}
		if (!empty($label)) {
			// uri rdfs:label $label
			$store->addStatement(
				$acModelUri,
				$userUri,
				EF_RDFS_LABEL,
				array(
					 'value' => $label,
					 'type' => 'literal'
				),
				false
			);
		}
		if (!empty($group)) {
			$store->addStatement(
				$acModelUri,
				$group,
				$this->configuration->ac->group->membership,
				array(
					 'value' => $userUri,
					 'type' => 'uri'
				),
				false
			);
		}
		return true;
	}

	/**
	 * Adds a new user to the store.
	 *
	 * @param string $username
	 * @param string $password
	 * @param string $email
	 * @param string|NULL $userGroupUri
	 * @return boolean
	 */
	public function addUser($username, $password, $email, $userGroupUri = '') {
		$acModel = $this->getAccessControlModel();
		$acModelUri = $acModel->getModelUri();
		$store = $acModel->getStore();
		$userUri = $acModelUri . urlencode($username);
		$store->addStatement(
			$acModelUri,
			$userUri,
			EF_RDF_TYPE,
			array(
				 'value' => $this->configuration->ac->user->class,
				 'type' => 'uri'
			),
			false
		);
		$store->addStatement(
			$acModelUri,
			$userUri,
			$this->configuration->ac->user->name,
			array(
				 'value' => $username,
				 'type' => 'literal',
				 'datatype' => EF_XSD_NS . 'string'
			),
			false
		);
		// Check whether email already starts with mailto:
		if (substr($email, 0, 7) !== 'mailto:') {
			$email = 'mailto:' . $email;
		}
		$store->addStatement(
			$acModelUri,
			$userUri,
			$this->configuration->ac->user->mail,
			array(
				 'value' => $email,
				 'type' => 'uri'
			),
			false
		);
		$store->addStatement(
			$acModelUri,
			$userUri,
			$this->configuration->ac->user->pass,
			array(
				 'value' => sha1($password),
				 'type' => 'literal'
			),
			false
		);
		if (!empty($userGroupUri)) {
			$store->addStatement(
				$acModelUri,
				$userGroupUri,
				$this->configuration->ac->group->membership,
				array(
					 'value' => $userUri,
					 'type' => 'uri'
				),
				false
			);
		}
		return true;
	}

	/**
	 * Authenticates a user with a given username and password.
	 *
	 * @param string $username
	 * @param string $password
	 * @return Zendauthentication_Result
	 */
	public function authenticate($username = 'Anonymous', $password = '') {
		// Set up the authentication adapter.
		$adapter = $this->objectManager->create('Erfurt\Authentication\Adapter\Typo3', $username, $password);
		// Attempt authentication, saving the result.
		$result = $this->getAuthentication()->authenticate($adapter);
		// If the result is not valid, make sure the identity is cleared.
		if (!$result->isValid()) {
			$this->getAuthentication()->clearIdentity();
		}
		return $result;
	}

	/**
	 * @param string $get
	 * @param string $redirectUrl
	 * @return \Zend_Auth_Result
	 */
	public function authenticateWithFoafSsl($get = NULL, $redirectUrl = NULL) {
		// Set up the authentication adapter.
		$adapter = $this->objectManager->create(\Erfurt\Authentication\Adapter\FoafSsl, $get, $redirectUrl);
		// Attempt authentication, saving the result.
		$result = $this->getAuthentication()->authenticate($adapter);
		// If the result is not valid, make sure the identity is cleared.
		if (!$result->isValid()) {
			$this->getAuthentication()->clearIdentity();
		}
		return $result;
	}

	/**
	 * The second step of the OpenID authentication process.
	 * Authenticates a user with a given OpenID. On success this
	 * method will not return but instead redirect the user to the
	 * specified URL.
	 *
	 * @param string $openId
	 * @param string $redirectUrl
	 * @return \Zend_Auth_Result
	 */
	public function authenticateWithOpenId($openId, $verifyUrl, $redirectUrl) {
		$adapter = new Erfurtauthentication_Adapter_OpenId($openId, $verifyUrl, $redirectUrl);
		$result = $this->getAuthentication()->authenticate($adapter);
		// If we reach this point, something went wrong with the authentication process...
		// So we always clear the identity.
		$this->getAuthentication()->clearIdentity();
		return $result;
	}

	/**
	 * Returns an instance of the access control class.
	 *
	 * @return \Erfurt\AccessControl\Standard
	 */
	public function getAccessControl() {
		if (NULL === $this->accessControl) {
			$this->accessControl = $this->objectManager->create('\Erfurt\AccessControl\Standard');
		}
		return $this->accessControl;
	}

	public function setAccessControl($accessControl) {
		$this->accessControl = $accessControl;
	}

	/**
	 * Returns an instance of the access control model.
	 *
	 * @return \Erfurt\Rdf\Model
	 */
	public function getAccessControlModel() {
		if (NULL === $this->accessControlModel) {
			$this->accessControlModel = $this->getStore()
					->getModel($this->getAccessControlConfiguration()->modelUri, false);
		}

		return $this->accessControlModel;
	}

	/**
	 * Convenience shortcut for Ac_Default::getActionConfig().
	 *
	 * @param string $actionSpec The action to get the configuration for.
	 * @return array Returns the configuration for the given action.
	 */
	public function getActionConfig($actionSpec) {
		return $this->getAccessControl()->getActionConfig($actionSpec);
	}

	/**
	 * Returns a caching instance.
	 *
	 * @return \Zend_Cache_Core
	 */
	public function getCache() {
		if (NULL === $this->cache) {
			if (!isset($this->getCacheConfiguration()->lifetime) || ($this->getCacheConfiguration()->lifetime == -1)) {
				$lifetime = NULL;
			} else {
				$lifetime = $this->getCacheConfiguration()->lifetime;
			}
			$frontendOptions = array(
				'lifetime' => $lifetime,
				'automatic_serialization' => true
			);
			$this->cache = $this->objectManager->create('\Erfurt\Cache\Frontend\ObjectCache', $frontendOptions);
			$backend = $this->getCacheBackend();
			$this->cache->setBackend($backend);
		}
		return $this->cache;
	}

	/**
	 * Returns a directory, which can be used for file-based caching.
	 * If no such (writable) directory is found, false is returned.
	 *
	 * @return string|false
	 */
	public function getCacheDir() {
		if (isset($this->getCacheConfiguration()->path)) {
			$matches = array();
			if (!(preg_match('/^(\w:[\/|\\\\]|\/)/', $this->getCacheConfiguration()->path, $matches) === 1)) {
				$this->getCacheConfiguration()->path = EF_BASE . $this->getCacheConfiguration()->path;
			}
			if (is_writable($this->getCacheConfiguration()->path)) {
				return $this->getCacheConfiguration()->path;
			} else {
				// Should throw an exception.
				return false;
				//return $this->getTmpDir();
			}
		} else {
			return false;
			//return $this->getTmpDir();
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Zend_Config
	 * @throws \Erfurt\Exception( Throws an exception if no config is loaded.
	 */
	public function getConfiguration() {
		if (NULL === $this->configuration) {
			throw new Exception\ConfigurationNotLoadedException('Configuration was not loaded.', 1302769700);
		} else {
			return $this->configuration;
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Erfurt\Configuration\AccessControlConfiguration
	 * @throws \Erfurt\Exception\ConfigurationNotLoadedException Throws an exception if no config is loaded.
	 */
	public function getAccessControlConfiguration() {
		if (NULL === $this->accessControlConfiguration) {
			throw new Exception\ConfigurationNotLoadedException('Access Control Configuration was not loaded.', 1303200116);
		} else {
			return $this->accessControlConfiguration;
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Erfurt\Configuration\AuthenticationConfiguration
	 * @throws \Erfurt\Exception\ConfigurationNotLoadedException Throws an exception if no config is loaded.
	 */
	public function getAuthenticationConfiguration() {
		if (NULL === $this->authenticationConfiguration) {
			throw new Exception\ConfigurationNotLoadedException('Authentication Configuration was not loaded.', 1303200166);
		} else {
			return $this->authenticationConfiguration;
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Erfurt\Configuration\CacheConfiguration
	 * @throws \Erfurt\Exception\ConfigurationNotLoadedException Throws an exception if no config is loaded.
	 */
	public function getCacheConfiguration() {
		if (NULL === $this->cacheConfiguration) {
			throw new Exception\ConfigurationNotLoadedException('Cache Configuration was not loaded.', 1303200192);
		} else {
			return $this->cacheConfiguration;
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Erfurt\Configuration\GeneralConfiguration
	 * @throws \Erfurt\Exception\ConfigurationNotLoadedException Throws an exception if no config is loaded.
	 */
	public function getGeneralConfiguration() {
		if (NULL === $this->generalConfiguration) {
			throw new Exception\ConfigurationNotLoadedException('Cache Configuration was not loaded.', 1304403865);
		} else {
			return $this->generalConfiguration;
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Erfurt\Configuration\NamespacesConfguration
	 * @throws \Erfurt\Exception\ConfigurationNotLoadedException Throws an exception if no config is loaded.
	 */
	public function getNamespacesConfiguration() {
		if (NULL === $this->namespacesConfiguration) {
			throw new Exception\ConfigurationNotLoadedException('Namespaces Configuration was not loaded.', 1302772392);
		} else {
			return $this->namespacesConfiguration;
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Erfurt\Configuration\SessionConfiguration
	 * @throws \Erfurt\Exception\ConfigurationNotLoadedException Throws an exception if no config is loaded.
	 */
	public function getSessionConfiguration() {
		if (NULL === $this->sessionConfiguration) {
			throw new Exception\ConfigurationNotLoadedException('Session Configuration was not loaded.', 1303200235);
		} else {
			return $this->sessionConfiguration;
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Erfurt\Configuration\StoreConfguration
	 * @throws \Erfurt\Exception\ConfigurationNotLoadedException Throws an exception if no config is loaded.
	 */
	public function getStoreConfiguration() {
		if (NULL === $this->storeConfiguration) {
			throw new Exception\ConfigurationNotLoadedException('Store Configuration was not loaded.', 1302772396);
		} else {
			return $this->storeConfiguration;
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Erfurt\Configuration\SystemOntologyConfiguration
	 * @throws \Erfurt\Exception\ConfigurationNotLoadedException Throws an exception if no config is loaded.
	 */
	public function getSystemOntologyConfiguration() {
		if (NULL === $this->systemOntologyConfiguration) {
			throw new Exception\ConfigurationNotLoadedException('System Ontology Configuration was not loaded.', 1303200655);
		} else {
			return $this->systemOntologyConfiguration;
		}
	}

	/**
	 * Returns the configuration object.
	 *
	 * @return \Erfurt\Configuration\UriConfiguration
	 * @throws \Erfurt\Exception\ConfigurationNotLoadedException Throws an exception if no config is loaded.
	 */
	public function getUriConfiguration() {
		if (NULL === $this->uriConfiguration) {
			throw new Exception\ConfigurationNotLoadedException('Uri Configuration was not loaded.', 1303203612);
		} else {
			return $this->uriConfiguration;
		}
	}

	/**
	 * Returns the event dispatcher instance.
	 *
	 * @return \Erfurt\Event\Dispatcher
	 */
	public function getEventDispatcher() {
		$eventDispatcher = $this->objectManager->get('\Erfurt\Event\Dispatcher');
		return $eventDispatcher;
	}

	/**
	 * Returns a preconfigured Http_Client
	 *
	 * @param string $uri
	 * @param array $options
	 * @return \Zend_Http_Client
	 */
	public function getHttpClient($uri, $options = array()) {
		$config = $this->getConfig();
		$defaultOptions = array();
		if (isset($config->proxy)) {
			$proxy = $config->proxy;
			if (isset($proxy->host)) {
				$defaultOptions['proxy_host'] = $proxy->host;
				$defaultOptions['adapter'] = '\Zend_Http_Client_Adapter_Proxy';
				if (isset($proxy->port)) {
					$defaultOptions['proxy_port'] = (int)$proxy->port;
				}
				if (isset($proxy->username)) {
					$defaultOptions['proxy_user'] = $proxy->username;
				}
				if (isset($proxy->password)) {
					$defaultOptions['proxy_pass'] = $proxy->password;
				}
			}
		}
		$finalOptions = array_merge($defaultOptions, $options);
		$client = new \Zend_Http_Client($uri, $finalOptions);
		return $client;
	}

	/**
	 * Returns a logging instance. If logging is disabled Zend_Log_Writer_Null is returned,
	 * so it is save to use this object without further checkings. It is possible to use
	 * different logging files for different contexts. Just use an additional identifier.
	 *
	 * @param string $logIdentifier Identifies the logfile (filename without extension).
	 * @return Zend_Log
	 */
	public function getLog($logIdentifier = 'erfurt') {
		return $this->objectManager->get('\Erfurt\Log\NullLogger');
	}

	/**
	 * Returns the namespace management module.
	 *
	 * @return \Erfurt\Namespaces\Namespaces
	 */
	public function getNamespaces() {
		if (NULL === $this->namespaces) {
			// options
			$namespacesOptions = array(
				'standard_prefixes' => ($this->getNamespacesConfiguration() !== NULL) ? $this
						->getNamespacesConfiguration()->toArray() : array(),
				'reserved_names' => isset($this->getUriConfiguration()->schemata) ? $this->getUriConfiguration()->schemata->toArray() : array()
			);
			$this->namespaces = $this->objectManager->create('\Erfurt\Namespaces\Namespaces', $namespacesOptions);
		}
		return $this->namespaces;
	}

	/**
	 * Returns a query cache instance.
	 *
	 * @return \Erfurt\Cache\Frontend\QueryCache
	 */
	public function getQueryCache() {
		if (NULL === $this->queryCache) {
			$this->queryCache = $this->objectManager->create('\Erfurt\Cache\Frontend\QueryCache');
			$backend = $this->getQueryCacheBackend();
			$this->queryCache->setBackend($backend);
		}
		return $this->queryCache;
	}

	/**
	 * Returns a instance of the store.
	 *
	 * @return \Erfurt\Store\Store
	 */
	public function getStore() {
		return $this->store;
	}

	/**
	 * @var \Erfurt\Store\Store $store
	 */
	public function setStore(\Erfurt\Store\Store $store) {
		$this->store = $store;
	}

	/**
	 * Returns an instance of the system ontology model.
	 *
	 * @return \Erfurt\Rdf\Model
	 */
	public function getSysOntModel() {
		if (NULL === $this->systemOntologyModel) {
			$this->systemOntologyModel = $this
					->getStore()
					->getModel($this->getSystemOntologyConfiguration()->modelUri, false);
		}
		return $this->systemOntologyModel;
	}

	/**
	 * Returns a valid tmp folder depending on the OS used.
	 *
	 * @return string
	 */
	public function getTemporaryDirectory() {
		// We use a Zend method here, for it already checks the OS.
		$temp = new \Zend_Cache_Backend();
		return $temp->getTmpDir();
	}

	/**
	 * Convenience shortcut for \Erfurt\Authentication\Adapter\Rdf::getUsers().
	 *
	 * @return array Returns a list of users.
	 */
	public function getUsers() {
		$tempAdapter = $this->objectManager->create('\Erfurt\Authentication\Adapter\Rdf');
		return $tempAdapter->getUsers();
	}

	/**
	 * Returns a versioning instance.
	 *
	 * @return \Erfurt\Versioning\Versioning
	 */
	public function getVersioning() {
		if (NULL === $this->versioning) {
			$this->versioning = $this->objectManager->create('\Erfurt\Versioning\Versioning');
		}
		return $this->versioning;
	}

	/**
	 * Convenience shortcut for Ac_Default::isActionAllowed().
	 *
	 * @param string $actionSpec The action to check.
	 * @return boolean Returns whether the given action is allowed for the current user.
	 */
	public function isActionAllowed($actionSpec) {
		return $this->getAccessControl()->isActionAllowed($actionSpec);
	}

	/**
	 * The third and last step of the OpenID authentication process.
	 * Checks whether the response is a valid OpenID result and
	 * returns the appropriate auth result.
	 *
	 * @param array $get The query part of the authentication request.
	 * @return \Zend_Auth_Result
	 */
	public function verifyOpenIdResult($get) {
		$adapter = $this->objectManager->create('\Erfurt\Authentication\Adapter\OpenId', NULL, NULL, NULL, $get);
		$result = $this->getAuthentication()->authenticate($adapter);
		if (!$result->isValid()) {
			$this->getAuthentication()->clearIdentity();
		}
		return $result;
	}

	/**
	 * Returns a cache backend as configured.
	 *
	 * @return \Zend_Cache_Backend
	 * @throws \Erfurt\Exception(
	 */
	protected function getCacheBackend() {
		if (NULL === $this->cacheBackend) {
			// TODO: fix cache, temporarily disabled
			if (!isset($this->getCacheConfiguration()->enable) || !(boolean)$this->getCacheConfiguration()->enable) {
				$this->cacheBackend = $this->objectManager->create('\Erfurt\Cache\Backend\Null');
			}
				// cache is enabled
			else {
				// check for the cache type and throw an exception if cache type is not set
				if (!isset($this->getCacheConfiguration()->type)) {
					throw new \Erfurt\Exception('Cache type is not set in config.');
				} else {
					// check the type an whether type is supported
					switch (strtolower($this->getCacheConfiguration()->type)) {
						case 'database':
							$this->cacheBackend = $this->objectManager->create('\Erfurt\Cache\Backend\Database');
							break;
						case 'sqlite':
							if (isset($this->getCacheConfiguration()->sqlite->dbname)) {
								$backendOptions = array(
									'cache_db_complete_path' => $this->getCacheDir() . $this->getCacheConfiguration()->sqlite->dbname
								);
							} else {
								throw new \Erfurt\Exception(
									'Cache database filename must be set for sqlite cache backend'
								);
							}
							$this->cacheBackend = new \Zend_Cache_Backend_Sqlite($backendOptions);
							break;
						default:
							throw new \Erfurt\Exception('Cache type is not supported.');
					}
				}
			}
		}
		return $this->cacheBackend;
	}

	/**
	 * Returns a query cache backend as configured.
	 *
	 * @return \Erfurt\Cache\Backend\QueryCache\Backend
	 * @throws \Erfurt\Exception(
	 */
	protected function getQueryCacheBackend() {
		if (NULL === $this->queryCacheBackend) {
			$backendOptions = array();
			if (!isset($this->getCacheConfiguration()->query->enable) || ((boolean)$this->getCacheConfiguration()->query->enable === false)) {
				$this->queryCacheBackend = $this->objectManager->create('\Erfurt\Cache\Backend\QueryCache\Null');
			} else {
				// cache is enabled
				// check for the cache type and throw an exception if cache type is not set
				if (!isset($this->getCacheConfiguration()->query->type)) {
					var_dump($this->getCacheConfiguration());
					throw new \Erfurt\Exception('Cache type is not set in config.');
				} else {
					// check the type an whether type is supported
					switch (strtolower($this->getCacheConfiguration()->query->type)) {
						case 'database':
							$this->queryCacheBackend = $this->objectManager->create('\Erfurt\Cache\Backend\QueryCache\Database');
							break;
						#                       case 'file':
						#                            $this->queryCacheBackend = new Erfurt_Cache_Backend_QueryCache_File();
						#                            break;
						#
						#                       case 'memory':
						#                            $this->queryCacheBackend = new Erfurt_Cache_Backend_QueryCache_Memory();
						#                            break;
						default:
							throw new \Erfurt\Exception('Cache type is not supported.');
					}
				}
			}
		}
		return $this->queryCacheBackend;
	}

}

?>